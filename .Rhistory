prop.test(year3, year4)
?prop.test
prop.test(year3, year4,
alternative = c("greater"))
prop.test(year3, year4,
alternative = c("less"))
a - b
B <- 10000
ans <- rep(-99999, B)
for (i in 1:B) {
x$SimOutcome <- sample(x$Year)
ans[i] <- sum(x$Type=="Touchback" & x$SimOutcome=="Y2016")
}
table(ans)
sum(ans >= 307) / B
this <- file.path("http://www.stat.yale.edu/~jay/230/Homework",
"Homework9/NewHavenExample/46.html")
z <- scan(this, what="", sep="\n")
temp2 <- z[grep("Bedroom", z)]
temp2 <- as.numeric(gsub(".*([0-9]+).*", "\\1", temp2))
temp2
temp2 <- z[grep("Bed", z)]
temp2 <- as.numeric(gsub(".*([0-9]+).*", "\\1", temp2))
temp2 <- z[grep("Bed", z)]
temp2 <- as.numeric(gsub(".*([0-9]+).*", "\\1", temp2))
?mansplainr
??mansplainr
devtools::install_github("hilaryparker/mansplainr")
?install.packages
install.packages(mansplainr)
install.packages("mansplainr")
install.packages("devtools")
library("devtools")
devtools::install_github("hilaryparker/mansplainr")
p <- 2 + x
x <- 3
p <- 2 + x
mansplain(p)
?library
library()
install(mansplainr)
install('mansplainr')
install("mansplainr")
devtools::install_github("hilaryparker/mansplainr")
?vector
a <- c(5 1 14 3 -5 12 -20)
a <- c(5, 1, 14, 3, -5, 12, -20)
b <- c( 0, 2, -4, 10, 4, -3, -4)
a + b
3a - 4b
3*a - 4*b
?length
length(a)
a*b
?scaler
a <- matrix(c(5, 1, 14, 3, -5, 12, -20), ncol=7, byrow=T)
b <- matrix(c( 0, 2, -4, 10, 4, -3, -4), ncol=7, byrow=T)
a + b
3*a - 4*b
length(a)
a%*%b
a <- matrix(c(10, 6, -5), ncol=3, byrow=T)
A <- matrix(c(1, 2, 3, 2, 7, 9), nrow=3, byrow=T)
A
A <- matrix(c(1, 2, 3, 2, 7, 9), nrow=2, byrow=T)
A
B <- matrix(c(1, 1, 1, 1, 2, 3, 1, 4, 3, 2, 1, 1), nrow=3, byrow=T)
B
A <- matrix(c(1, 2, 3, 2, 7, 9), ncol=3, byrow=T)
A
B <- matrix(c(1, 1, 1, 1, 2, 3, 1, 4, 3, 2, 1, 1), ncol=4, byrow=T)
B
a <- matrix(c(1, 3, 2, 5, 2, 3, 5, 6), ncol=1, byrow=T)
a
atrans <- t(matrixa)
atrans <- t(a)
atrans%*%A%*%B
atrans
A
A <- matrix(c(2, 6, 8, 4, 2, 6, 3, -2, 1), ncol=3, byrow=T)
A
solve(A)
K <- matrix(c(1, 3, 2, 4), ncol=2, byrow=T)
K
eigen(K)
A <- 3, 9, 12, 4, 6, 0, 2, -3, 17, -5, 3, 1, 19, 19, 19, 19), ncol=4, byrow=T)
A <- matrix(c(3, 9, 12, 4, 6, 0, 2, -3, 17, -5, 3, 1, 19, 19, 19, 19), ncol=4, byrow=T)
B <- matrix(c(132, 120, 156, 210, 255, 255, 255, 0, 130, 132, 156, 1, 130, 130, 1, 9), ncol=4, byrow=T)
t(B)
B
A%*%B
solve(A)
det(A)
A1 <- solve(A)
A1
A%*%A1
B
TraceB <- 132+255+156+9
A%*%A1
TraceB
TraceB
TraceB
TransB <- t(B)
TransB
TraceTransB <- 132+255+156+9
TraceTransB
?update
library(readxl)
PS1_GDP_Data <- read_excel("~/Documents/Yale/Spring17/Macro/PS1_GDP_Data.xls")
View(PS1_GDP_Data)
?data.entry
data.entry
data.frame
?data.frame
?t.test
library("RStata")
library(RStata)
s <- 1.96^2
pi
p <- pi*(1-pi)
n <- .02^2
k <- (s*p)/n
k
a <- (.04^2)
(s*p)/a
p <- .5^2
s <- 1.96^2
p <- .5^2
n <- .02^2
a <- (.04^2)
k <- (s*p)/n
k
k <- (s*p)/a
k
b <- .025^2
k <- (s*p)/b
k
(s*p)/b
?prop.test
par(ask=FALSE)
library(TeachingDemos)
library(fpc)
library(cluster)
cereal=read.csv("http://reuningscherer.net/stat660/data/cereal.attitudes.csv",header=T)
faces(cereal[,-1], labels=cereal[,1], ncol=3)
library(TeachingDemos)
?Teaching
install.packages(TeachingDemos)
?TeachingDemos-package
install.packages(TeachingDemos-package)
library(TeachingDemos-package )
TeachingDemos-package
install.packages("TeachingDemos")
install.packages("fpc")
library(TeachingDemos)
library(fpc)
library(cluster)
cereal=read.csv("http://reuningscherer.net/stat660/data/cereal.attitudes.csv",header=T)
faces(cereal[,-1], labels=cereal[,1], ncol=3)
stars(cereal[,-1], labels=as.character(cereal[,1]), ncol=4)
stars(cereal[,-1], labels=as.character(cereal[,1]), ncol=4, draw.segments=T)
wbclust=read.csv("http://reuningscherer.net/stat660/data/WBClust2013.csv",header=T)
wbnorm<-scale(wbclust[,2:13])
rownames(wbnorm)=wbclust[,1]
dist1<-dist(wbnorm, method="euclidean")
clust1<-hclust(dist1,method="ward.D")
plot(clust1,labels= wbclust$Country, cex=0.7, xlab="",ylab="Distance",main="Clustering for 80 Most Populous Countries")
rect.hclust(clust1,k=5)
cuts=cutree(clust1,k=5)
cuts
for (i in 1:5){
print(paste("Countries in Cluster ",i))
print(wbclust$Country[cuts==i])
print (" ")
}
faces(cereal[,-1], labels=cereal[,1], ncol=3)
source("http://reuningscherer.net/stat660/R/HClusEval.R.txt")
hclus_eval(wbnorm, dist_m = 'euclidean', clus_m = 'ward', plot_op = T)
clusplot(wbnorm, cuts, color=TRUE, shade=TRUE, labels=2, lines=0,
main="World Bank Five Cluster Plot, Ward's Method, First two PC")
plotcluster(wbnorm, cuts, main="Five Cluster Solution in DA Space",
xlab="First Discriminant Function", ylab="Second Discriminant Function")
NASA=read.csv("http://reuningscherer.net/stat660/data/NASA1/snf/NASAUnderstory.csv",header=T)
NASA.lab=NASA$Labels
NASA=NASA[,-32]
NASAscale<-scale(NASA[,3:31])
rownames(NASAscale)=as.factor(NASA$Overstory.Species)
dist1<-dist(NASAscale, method="euclidean")
clust1<-hclust(dist1,method="ward.D")
plot(clust1,labels= NASA[,2], cex=0.5, xlab="",ylab="Distance",main="Clustering for NASA Understory Data")
rect.hclust(clust1,k=2)
cuts=cutree(clust1,k=2)
cuts
source("http://reuningscherer.net/stat660/R/HClusEval.R.txt")
hclus_eval(NASAscale, dist_m = 'euclidean', clus_m = 'ward', plot_op = T)
library(vegan)
install.packages("vegan")
library(vegan)
NASA
dist1<-vegdist(NASA[,3:31], method="jaccard", upper=T)
clust1<-hclust(dist1,method="ward.D")
plot(clust1,labels= NASA[,2], cex=0.5, xlab="",ylab="Distance",main="Clustering for NASA Understory Data")
rect.hclust(clust1,k=2)
cuts=cutree(clust1,k=2)
cuts
clusplot(NASA, cuts, color=TRUE, shade=TRUE, labels=2, lines=0,
main="NASA Two Cluster Plot, Ward's Method, First two PC")
plotcluster(NASA[,3:31], cuts, main="Two Cluster Solution in DA Space",
xlab="First Discriminant Function", ylab="Second Discriminant Function")
NASAtrans=t(NASAscale)
dist1<-dist(NASAtrans, method="minkowski", p=3)
clust1<-hclust(dist1,method="ward.D")
plot(clust1,labels= NASA.lab[1:29], cex=1, xlab="",ylab="Distance",main="Clustering for NASA Understory Data")
rect.hclust(clust1,k=3)
cuts=cutree(clust1,k=3)
cuts
source("http://reuningscherer.net/stat660/R/HClusEval.R.txt")
hclus_eval(NASAtrans, dist_m = 'euclidean', clus_m = 'ward', plot_op = T)
km1=kmeans(wbnorm,centers=5)
for (i in 1:5){
print(paste("Countries in Cluster ",i))
print(wbclust$Country[km1$cluster==i])
print (" ")
}
kdata=wbnorm
n.lev=15  #set max value for k
wss <- rnorm(10)
while (prod(wss==sort(wss,decreasing=T))==0) {
wss <- (nrow(kdata)-1)*sum(apply(kdata,2,var))
for (i in 2:n.lev) wss[i] <- sum(kmeans(kdata, centers=i)$withinss)}
k.rand <- function(x){
km.rand <- matrix(sample(x),dim(x)[1],dim(x)[2])
rand.wss <- as.matrix(dim(x)[1]-1)*sum(apply(km.rand,2,var))
for (i in 2:n.lev) rand.wss[i] <- sum(kmeans(km.rand, centers=i)$withinss)
rand.wss <- as.matrix(rand.wss)
return(rand.wss)
}
rand.mat <- matrix(0,n.lev,250)
k.1 <- function(x) {
for (i in 1:250) {
r.mat <- as.matrix(suppressWarnings(k.rand(kdata)))
rand.mat[,i] <- r.mat}
return(rand.mat)
}
k.2.rand <- function(x){
rand.mat <- matrix(0,n.lev,250)
km.rand <- matrix(sample(x),dim(x)[1],dim(x)[2])
rand.wss <- as.matrix(dim(x)[1]-1)*sum(apply(km.rand,2,var))
for (i in 2:n.lev) rand.wss[i] <- sum(kmeans(km.rand, centers=i)$withinss)
rand.wss <- as.matrix(rand.wss)
return(rand.wss)
}
k.2 <- function(x){
for (i in 1:250) {
r.1 <- k.2.rand(kdata)
rand.mat[,i] <- r.1}
return(rand.mat)
}
if (dim(kdata)[2] == 2) { rand.mat <- k.2(kdata) } else { rand.mat <- k.1(kdata) }
xrange <- range(1:n.lev)
yrange <- range(log(rand.mat),log(wss))
plot(xrange,yrange, type='n', xlab='Cluster Solution', ylab='Log of Within Group SSE', main='Cluster Solutions against Log of SSE')
for (i in 1:250) lines(log(rand.mat[,i]),type='l',col='red')
lines(log(wss), type="b", col='blue')
legend('topright',c('Actual Data', '250 Random Runs'), col=c('blue', 'red'), lty=1)
yrange <- range(rand.mat,wss)
plot(xrange,yrange, type='n', xlab="Cluster Solution", ylab="Within Groups SSE", main="Cluster Solutions against SSE")
for (i in 1:250) lines(rand.mat[,i],type='l',col='red')
lines(1:n.lev, wss, type="b", col='blue')
legend('topright',c('Actual Data', '250 Random Runs'), col=c('blue', 'red'), lty=1)
r.sse <- matrix(0,dim(rand.mat)[1],dim(rand.mat)[2])
wss.1 <- as.matrix(wss)
for (i in 1:dim(r.sse)[2]) {
r.temp <- abs(rand.mat[,i]-wss.1[,1])
r.sse[,i] <- r.temp}
r.sse.m <- apply(r.sse,1,mean)
r.sse.sd <- apply(r.sse,1,sd)
r.sse.plus <- r.sse.m + r.sse.sd
r.sse.min <- r.sse.m - r.sse.sd
xrange <- range(1:n.lev)
yrange <- range(log(r.sse.plus),log(r.sse.min))
plot(xrange,yrange, type='n',xlab='Cluster Solution', ylab='Log of SSE - Random SSE', main='Cluster Solustions against (Log of SSE - Random SSE)')
lines(log(r.sse.m), type="b", col='blue')
lines(log(r.sse.plus), type='l', col='red')
lines(log(r.sse.min), type='l', col='red')
legend('topright',c('SSE - random SSE', 'SD of SSE-random SSE'), col=c('blue', 'red'), lty=1)
xrange <- range(1:n.lev)
yrange <- range(r.sse.plus,r.sse.min)
plot(xrange,yrange, type='n',xlab='Cluster Solution', ylab='SSE - Random SSE', main='Cluster Solutions against (SSE - Random SSE)')
lines(r.sse.m, type="b", col='blue')
lines(r.sse.plus, type='l', col='red')
lines(r.sse.min, type='l', col='red')
legend('topright',c('SSE - random SSE', 'SD of SSE-random SSE'), col=c('blue', 'red'), lty=1)
choose.clust <- function(){readline("What clustering solution would you like to use? ")}
clust.level <- as.integer(choose.clust())
aggregate(kdata, by=list(fit$cluster), FUN=mean)
clust.out <- fit$cluster
kclust <- as.matrix(clust.out)
?confint
205/400
library(CatterPlots)
x <- -10:10
y <- -x^2 + 10
purr <- catplot(xs=x, ys=y, cat=3, catcolor=c(0,1,1,1))
cats(purr, -x, -y, cat=4, catcolor=c(1,0,1,1))
meow <- multicat(xs=x, ys=y, cat=c(1,2,3), catcolor=list(c(1,1,0,1),c(0,1,1,1)), canvas=c(-0.1,1.1, -0.1, 1.1))
morecats(purr, x, 10*sin(x)+40, size=0.05, cat=c(4,5,6), catcolor=list(c(0,0,1,1),c(0,1,0,1)), type="line")
meow <- multicat(xs=x, ys=rnorm(21),
cat=c(1,2,3,4,5,6,7,8,9,10),
catcolor=list(c(0,0,0,1)),
canvas=c(-0.1,1.1, -0.1, 1.1),
xlab="some cats", ylab="other cats", main="Random Cats")
prop.test(.375)
install.packages("shiny")
library("shiny")
runExample("01_hello")
function(input, output) {
# Expression that generates a histogram. The expression is
# wrapped in a call to renderPlot to indicate that:
#
#  1) It is "reactive" and therefore should be automatically
#     re-executed when inputs change
#  2) Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful[, 2]  # Old Faithful Geyser data
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
}
runExample("01_hello")
runExample("02_text")
runExample("03_reactivity")
cereal <- read.csv("http://reuningscherer.net/stat660/data/cereal.attitudes.csv")
library(vegan)
install.packages(vegan)
install.packages("vegan")
library(vegan)
alaska = read.csv("http://www.reuningscherer.net/stat660/data/log.alaska.stream.data.csv", header=T)
alaska<-alaska[apply(alaska[,4:14],1,sum)>0,]
alaskacca<-cca(alaska[,4:14])
plot(alaskacca, type="n" ,xlim=c(-2,2.5))
text(alaskacca, dis="wa",labels=alaska[,3])
points(alaskacca, pch=21, col="red", bg="yellow", cex=1.2)
text(alaskacca, "species", col="blue", cex=0.8)
alaskadca<-decorana(alaska[,4:14])
plot(alaskadca,type="n")
text(alaskadca, display=c("sites"),labels=alaska[,3],cex=0.86)
points(alaskadca, pch=21, col="red", bg="yellow", cex=0.6)
text(alaskadca, "species", col="blue", cex=0.6)
rownames(alaska)<-alaska$StreamID
alaska<-alaska[,-c(1:3)]
results=matrix(0,21,5)
for (j in 1:5){
for (i in 1:20){
temp=alaska[shuffle(nrow(alaska)),1]
for (k in 2:11) { temp=cbind(temp,alaska[shuffle(nrow(alaska)),k]) }
results[i,j]=metaMDS(temp,k=j,distance="euclidean")$stress
}
results[21,j]=metaMDS(alaska[,1:11],k=j, distance="euclidean")$stress
}
plot(c(1:5),results[21,],type="b", col="blue", lwd=3,
ylim=c(0, max(results)), xlab="Dimensions", ylab="Stress", pch=19,
main="MDS for Stream Data, Euclidean Distance")
mins=apply(results[1:20,],2,min)
maxs=apply(results[1:20,],2,max)
meds=apply(results[1:20,],2,median)
for (i in 1:5){
points(rep(i,3),c(mins[i], meds[i], maxs[i]),type="b", col="red", lwd=3, pch=19)
}
legend(3.5,(.9*max(results)),c("MDS Solution", "20 Permutations"), lwd=3, col=c("blue","red"))
alaska.mds2=metaMDS(alaska[,1:11],k=2, distance="euclidean")
plot(alaska.mds,type="t")
fig<-ordiplot(alaska.mds2,type="none",cex=1.1)
text(fig,"species",col="red",cex=1.1)
text(fig,"sites",col="blue",cex=0.8)
alaska.mds2=metaMDS(alaska[,1:11],k=2)
fig<-ordiplot(alaska.mds2,type="none",cex=1.1)
text(fig,"species",col="red",cex=1.1)
text(fig,"sites",col="blue",cex=0.8)
plot(alaska.mds2,type="t")
city = read.csv("http://www.reuningscherer.net/stat660/data/CityDistance.csv", header=T)
rownames(city)<-city[,1]
city <-city [,-1]
city.mds1<-metaMDS(city, distance="euclidean", k=1)
city.mds2<-metaMDS(city, distance="euclidean", k=2)
city.mds3<-metaMDS(city, distance="euclidean", k=3)
city.mds4<-metaMDS(city, distance="euclidean", k=4)
stress=c(city.mds1$stress, city.mds2$stress, city.mds3$stress, city.mds4$stress)
plot(c(1:4),stress,col="blue",lwd=3, type="b", xlab="Dimensions")
plot(city.mds2,type="t", cex=1.2,)
spidercount <- read.delim("http://reuningscherer.net/stat660/data/sqrtspidercount.txt", sep="\t", row.names=1)
spiderenv <- read.delim("http://reuningscherer.net/stat660/data/spiderenvironmentalvars.txt", sep="\t", row.names=1)
library(vegan)
spiderca<-cca(spidercount)
plot(spiderca,main="Correspondence Analysis for Spider Data",type="n")
points(spiderca, pch=19, col="black", cex=1)
text(spiderca, "species", col="blue", cex=1.1)
fit<-envfit(spiderca, spiderenv,permutations=1000)
plot(fit,col="red",lwd=3)
fit
spiderdca<-decorana(spidercount)
plot(spiderdca,main="DCA for Spider Data",type="n")
points(spiderdca, pch=19, col="black", cex=1)
text(spiderdca, "species", col="blue", cex=1.1)
fit<-envfit(spiderdca, spiderenv,permutations=1000)
plot(fit,col="red",lwd=3)
spidermds<-metaMDS(spidercount)
plot(spidermds,main="NMDS for Spider Data",type="n")
points(spidermds, pch=19, col="black", cex=1)
text(spidermds, "species", col="blue", cex=1.1)
fit<-envfit(spidermds, spiderenv,permutations=1000)
plot(fit,col="red",lwd=3)
spidercca<-cca(spidercount,spiderenv,scale="FALSE")
plot(spidercca)
plot(spidercca,main="CCA for Spider Data",type="n")
points(spidercca, pch=19, col="black", cex=1)
text(spidercca, "species", col="blue", cex=1.1)
fit<-envfit(spidercca, spiderenv,permutations=1000)
plot(fit,col="red",lwd=3)
fit
summary(spidercca)
spidernmds<-metaMDS(spidercount)
fit1<-envfit(spidernmds~BareSand+FallTwig, spiderenv)
fit2<-envfit(spidernmds~WaterCon+CoveMoss, spiderenv)
fig<-ordiplot(spidernmds,type="none",cex=1.1,main="NMDS for Spider Data")
text(fig,"species",col="red",cex=0.7)
text(fig,"sites",col="black",cex=0.7)
plot(fit1)
tmp1 <- with(spiderenv, ordisurf(spidernmds, BareSand, add = TRUE))
tmp2<-with(spiderenv, ordisurf(spidernmds, FallTwig, add = TRUE, col = "green4"))
fig<-ordiplot(spidernmds,type="none",cex=1.1,main="NMDS for Spider Data")
text(fig,"species",col="red",cex=0.7)
text(fig,"sites",col="black",cex=0.7)
plot(fit2)
tmp1 <- with(spiderenv, ordisurf(spidernmds, WaterCon, add = TRUE))
tmp2<-with(spiderenv, ordisurf(spidernmds, CoveMoss, add = TRUE, col = "green4"))
vis.gam(tmp1,main="BareSand")
vis.gam(tmp2,main="FallTwig")
install.packages("RXKCD", repos="http://R-Forge.R-project.org", type="source")
searchXKCD("support")
install.packages("RXKCD")
searchXKCD("support")
?RXKCD
require(MASS)
library(animation)
install.packages("animation")
library(animation)
mkmovie = TRUE  #guarantees some form of output
param <- c(50-30i,18+8i,12-10i,-14-60i,1+20i)
parar <- param * exp(1i*pi/2)  #rotate by 90 degrees
pinky <- function() {
Cx <- as.complex(rep(0,length(param)))
Cy <- as.complex(rep(0,length(param)))
tv <- seq(0,2*pi,length=1000)
for (i in 1:2) { #movie frames
Cx[1] <- parar[1] + Im(param[1])
Cx[2] <- parar[2] + Im(param[2])
Cx[3] <- Re(param[3])
Cx[4] <- Re(param[5]) - (i-1)
Cx[5] <- Re(param[4])
Cy[1] <- param[1] - Re(param[1]) + Im(param[4])
Cy[2] <- param[2] - Re(param[2])
Cy[3] <- param[3] - Re(param[3])
x <- c(fourier(tv, Cx))
y <- c(fourier(tv, Cy))
plot(y, -x, type="l", col='red', lwd=10, axes=FALSE, ylab='', xlab='')
lines(y, -x, type="l", col='pink', lwd=4)
if (i > 1) points(Im(param[5]), Im(param[5]), col='black', pch=126, cex=2)
else points(Im(param[5]), Im(param[5]), col='black', pch=20, cex=2)
}
}
fourier <- function(tt,cc) {
wt <- rep(0, length(tt))
fsum <- function(n) {
if (n > 0) wt <- wt + fsum(n-1) + Re(cc[n]) * cos(n*tt) + Im(cc[n]) * sin(n*tt)
return(wt)
}
fsum(length(cc))
}
if (mkmovie) {
aopt = ani.options(interval = 0, nmax = 2)
saveMovie(pinky(), interval = 0.25, outdir = getwd(), width = 400, height = 400)
ani.options(aopt)
} else pinky()
pinky
t <- q[,-c(1,39)]
corrmat <- round(cor(t),2)
names()
data()
x <- esoph
table(x$ncases)
iris
head(mtcars)
table(mtcars$vs)
x <- mtcars
?rename
x$manual <- x$am
x <- mtcars
colname(x)[9] <- "manual"
colnames(x)[9] <- "manual"
lm.1 <- lm(manual ~ mpg, data=x)
plot(manual ~ mpg, data=x)
plot(mpg ~ manual, data=x)
lm.1 <- lm(mpg ~ manual, data=x)
summary(lm.1)
lm.2 <- lm(manual~mpg, data=x)
summary(lm.2)
summary(lm.1)
setwd("/Users/katdevlin/Desktop/blog/KatDevlin.github.io")
rmarkdown::render_site()
rmarkdown::render_site()
